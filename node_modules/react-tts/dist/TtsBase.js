"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("core-js/modules/web.dom-collections.iterator.js");

var _react = require("react");

var _useTts = _interopRequireDefault(require("./useTts"));

var _jsxRuntime = require("react/jsx-runtime");

const _excluded = ["Component", "autoplay", "lang", "pitch", "rate", "text", "voice", "volume", "onEnd", "onError", "onPause", "onResume", "onStart", "synth"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const TtsBase = /*#__PURE__*/(0, _react.forwardRef)((_ref, ref) => {
  let {
    Component,
    autoplay,
    lang,
    pitch,
    rate,
    text,
    voice,
    volume,
    onEnd,
    onError,
    onPause,
    onResume,
    onStart,
    synth
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded);

  const {
    cancel: ttsCancel,
    pause: ttsPause,
    resume: ttsResume,
    speak: ttsSpeak
  } = (0, _useTts.default)(synth);
  const [play, setPlay] = (0, _react.useState)(autoplay);

  const getInnerText = obj => {
    const text = [];

    const dfs = children => {
      if (!Array.isArray(children)) children = [children];
      children.forEach(child => {
        var _child$props;

        switch (typeof child) {
          case "undefined":
            break;

          case "symbol":
            break;

          case "bigint":
            break;

          case "object":
            return dfs((_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.children);

          default:
            text.push(child);
        }
      });
    };

    dfs(obj);
    return text.join(' ');
  };

  const handle = (method, callback) => {
    try {
      method();
      if (!!callback) callback();
    } catch (e) {
      if (!!onError) onError(e);
      throw e;
    }
  };

  const cancel = () => handle(ttsCancel, onEnd);

  const pause = () => handle(ttsPause, onPause);

  const resume = () => handle(ttsResume, onResume);

  const speak = () => {
    cancel();
    const speech = new SpeechSynthesisUtterance(text || getInnerText(props.children));
    if (!!lang) speech.lang = lang;
    if (!!onEnd) speech.onend = onEnd;
    if (!!onStart) speech.onstart = onStart;
    if (!!pitch) speech.pitch = pitch;
    if (!!rate) speech.rate = rate;
    if (!!voice) speech.voice = voice;
    if (!!volume) speech.volume = volume;
    return handle(() => {
      ttsResume();
      ttsSpeak(speech);
    }, null);
  };

  const speakCallback = (0, _react.useCallback)(speak, [speak]);
  (0, _react.useEffect)(() => {
    if (play) {
      setPlay(false);
      speakCallback();
    }
  }, [play, speakCallback]);
  (0, _react.useImperativeHandle)(typeof ref === 'object' ? ref : null, () => ({
    cancel,
    pause,
    resume,
    speak
  }));
  return !!Component ? /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, _objectSpread({}, props)) : /*#__PURE__*/(0, _jsxRuntime.jsx)("div", _objectSpread({}, props));
});
TtsBase.defaultProps = {
  Component: null,
  autoplay: false,
  lang: document.documentElement.lang,
  pitch: null,
  rate: null,
  text: '',
  voice: null,
  volume: null,
  onEnd: null,
  onError: null,
  onPause: null,
  onResume: null,
  onStart: null,
  synth: window.speechSynthesis
};
var _default = TtsBase;
exports.default = _default;